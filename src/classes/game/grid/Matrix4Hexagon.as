package classes.game.grid
{
	/**
	 * <h1>Идентификация элементов гексагона</h1>
	 * <p>
	 * Класс устанавливает соответствие между гексагональной решеткой и представляющей ее
	 * квадратной матрицей, позволяя задать присвоить каждому элементу гексагона
	 * уникальный идентификатор следующим образом:
	 * <ul>
	 * <li>вертикальные ряды гексагона задаются с помощью элементов в столбцах матрицы;</li>
	 * <li>нисходящие ряды гексагона задаются с помощью элементов в строках матрицы;</li>
	 * <li>восходящие ряды гексагона задаются с помощью элементов в восходящих диагоналях матрицы.</li>
	 * </ul>
	 * </p>
	 * <p>
	 * Необходимо отметить, что для некоторых элементов матрицы (находящихся в левом верхнем и правом нижнем
	 * углах матрицы) не существует соответсвующих элементов гексагона. Эти элементы матрицы равны нулю.
	 * Элементы матрицы, для которых существуют соответствующие им элементы гексагона, равны 1, и при этом 
	 * номер столбца и номер строки такого элемента формируют уникальный идентификатор каждого элемента гексагона.
	 * </p>
	 * <p>
	 * Ниже приведен пример матрицы 7 х 7, моделирущей гексагон, состоящий из трех рядов вокруг центрального элемента:<br />
	 * 0 0 0 1 1 1 1 <br />
	 * 0 0 1 1 1 1 1 <br />
	 * 0 1 1 1 1 1 1 <br />
	 * 1 1 1 1 1 1 1 <br />
	 * 1 1 1 1 1 1 0 <br />
	 * 1 1 1 1 1 0 0 <br />
	 * 1 1 1 1 0 0 0 <br />
	 * Как видно, единичные элементы матрицы формируют шестиугольник, похожий на искаженный гексагон, в котором, тем не менее,
	 * можно выделить три вышеупомянутых направления.
	 * </p>
	 * */
	public class Matrix4Hexagon
	{
		private var _matrix:Vector.<Vector.<int>>;
		
		public function Matrix4Hexagon(circleNum:int)
		{
			initMatrix(circleNum);
		}
		
		private function initMatrix(circleNum:int):void{
			var length:int = circleNum * 2 + 1;
			_matrix = new Vector.<Vector.<int>>;
			for(var i:int = 0; i < length; i++){
				var column:Vector.<int> = new Vector.<int>;
				for(var j:int = 0; j < length; j++){
					// обнуляем элементы матрицы в левом верхнем углу
					if((j < (length - 1) / 2 - i) && ((length - 1) / 2 > i)){
						column.push(0);
					}
					// обнуляем элементы матрицы в правом нижнем углу
					else if((j > 3 * (length - 1) / 2 - i) && (i > (length - 1) / 2)){
						column.push(0);	
					}
					else{
						column.push(1);
					}
				}
				_matrix.push(column);
			}
		}
		
		public function get matrix():Vector.<Vector.<int>>{
			return _matrix;
		}
		
		/*
		private function checkMatrix():void{
			for(var i:int = 0; i < _matrix.length; i++){
				var str:String = i.toString();
				str += ": ";
				for(var j:int = 0; j < _matrix[i].length; j++){
					str += _matrix[i][j].toString();
					str += " ";
					
				}
				//str += "\n";
				trace(str);
			}
		}
		*/
	}
}
package classes.levels
{
	/**
	 * <h1>Прогресс выполнения единичной цели уровня</h1>
	 * <p>Отслеживает текущее состояние выполнения единичной цели (задания).</p>
	 * <p>
	 * Содержит следующие переменные:
	 * <ul>
	 * <li><b><i>_spec</i></b> - спецификация текущего задания;</li>
	 * <li><b><i>_best</i></b> - лучший результат предыдущих прохождений уровня;</li>
	 * <li><b><i>_current</i></b> - текущее состояние выполнения задания;</li>
	 * <li><b><i>_isCompleted</i></b> - выполнено или нет единичное задание;</li>
	 * </ul>
	 * ... и открытые методы:
	 * <ul>
	 * <li><b><i>update()</i></b> - обновляет текущее состояние выполнения задания;</li>
	 * <li><b><i>get best()</i></b> <i>[Read Only]</i> - возвращает лучший результат предыдущих прохождений уровня;</li>
	 * <li><b><i>get current()</i></b> <i>[Read Only]</i> - возвращает текущее состояние выполнения задания;</li>
	 * <li><b><i>get isCompleted()</i></b> <i>[Read Only]</i> - сообщает, выполнено или нет единичное задание;</li>
	 * <li><b><i>resume()</i></b> - подводит итоги уровня, вычисляя наилучший результат;</li>
	 * <li><b><i>restart()</i></b> - подготавливает новое прохождение уровня.</li>
	 * </ul>
	 * </p>
	 * <h1>Назначение переменной <i>_best</i></h1>
	 * <p>
	 * Каждый раз, начиная прохождение текущего уровня, необходимо установить значение
	 * переменной <i>_current</i> равным нулю (иначе уровень автоматически становится выполненным). Чтобы не потерять информацию
	 * о предыдущих попытках, вероятно, можно было бы использовать массив целочисленных переменных с результатами <i>всех</i>
	 * предыдущих прохождений уровня. Но такая информация вряд ли интересует пользователя - гораздо интереснее <i>наилучший</i>
	 * результат. Именно для его хранения и предназначена переменная <i>_best</i>.</p>
	 * <p>Таким образом, совместное использование переменных <i>_current</i> и <i>_best</i> позволяет проходить один и тот же уровень
	 * многократно, и в то же время не потерять наилучший результат прохождения.</p>
	 * */
	public class SingleGoalProgress
	{
		private var _spec:SingleGoalSpec;
		private var _best:int;
		private var _current:int;
		private var _isCompleted:Boolean;
		
		/**
		 * <h1>Прогресс выполнения единичной цели уровня</h1>
	 	 * <p>Отслеживает текущее состояние выполнения единичной цели (задания).</p>
		 * <p>Конструктор принимает единственный параметр - <i>ps</i>, являющийся экземпляром класса <i>SingleGoalSpec</i>
		 * и определяющий спецификацию единичного задания, выполнение которого отслеживает данный объект.</p>
		 * */
		public function SingleGoalProgress(ps:SingleGoalSpec)
		{
			init(ps);
		}
		
		private function init(ps:SingleGoalSpec):void{
			_spec = ps.clone();
			_best = 0;
			_current = 0;
			_isCompleted = false;
		}
		
		/** обновление состояния выполнения единичного задания */
		public function update(pdelta:int = 1):void{
			_current += pdelta;
			if(_current >= _spec.needed) _isCompleted = true;
		}
		
		/** возвращает спецификацию единичного задания */
		public function get spec():SingleGoalSpec{
			return _spec;
		}
		
		/** возвращает текущее состояние выполнения единичного задания */
		public function get current():int{
			return _current;
		}
		
		/** возвращает лучший результат предыдущих прохождений уровня */
		public function get best():int{
			return _best;
		}
		
		/** возвращает значение, показывающее, выполнено или нет текущее единичное задание */
		public function get isCompleted():Boolean{
			return _isCompleted;
		}
		
		/** подводит итоги уровня, сравнивая полученный результат с лучшим из предыдущих */
		public function resume():void{
			if(_current > _best){
				_best = _current;
			}
			_current = 0;
			_isCompleted = false;
		}
		
		/* подготавливает новое прохождение уровня
		public function restart():void{
			_current = 0;
		}
		*/
	}
}